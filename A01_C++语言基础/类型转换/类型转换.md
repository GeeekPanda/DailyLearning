当赋值运算符左右两侧类型不同，或者形参和实参类型不匹配，亦或者返回类型与接受返回值的变量的类型不同时，就会发生类型转换。

在C语言中，有两种类型转换：
- 隐式类型转换：编译器编译阶段自动进行；
- 显式类型转换：程序员自己指定。

隐式类型转换中，转换原则为将数据类型升级为二者中更大的那个的数据类型。即小的向大的转化。大的向小的不能自动转换，会有精度丢失的风险。
>  bool -> char -> short int -> int -> unsigned int -> long -> unsigned long -> long long;

> float -> double -> long double;

显示类型转换的形式为：(数据类型)(表达式)
转换后不会改变原数据的类型及变量值，只在本次运算中临时性转换。


C风格的转换格式很简单，但是有不少缺点的：
1. 隐式类型转化有些情况下可能会出问题：比如数据精度丢失；
2. 显式类型转换将所有情况混合在一起，代码不够清晰。

因此C++提出了自己的类型转化风格，注意因为C++要兼容C语言，所以C++中还可以使用C语言的转化风格。


在C++中，使用C风格的隐式转换时有一个特殊情况，当类中带有仅有一个参数的构造函数时，将执形对象的隐式转换，比如有类A，有一个带有一个参数的构造函数A(int i){}；则当出现语句A m=1;就会调用带有一个参数的构造函数来创建对象m，也就是将语句转换为A m(1)的形式.

如果不需要这种隐式的类型转换则在构造函数前使用关键字explicit，这个关键字只能用于构造函数前。如果在构造
函数前使用explicit 关键字，这时语句A m=1 和f(2)都将出错。


C++中强制类型转换函数有4个：
- const_cast：
用于去除底层const属性，使指向常量的指针/引用变为普通指针/引用。
- static_cast：用于基本类型的强制转换，除了不能去除底层cost外，其他的具有明确含义的转换都可以做，比如加上const，转换指针类型等。也可以对父子类型之间进行转换，使用static_cast来进行向下转换是不安全的，因为当子类中定义了基类没有的变量，通过转换后的指针访问这个变量，程序将会报错。
- dynamic_cast：用于多态类型之间的类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。
dynamic一般用于基类指向派生类时的强制转换，转换成功返回true，失败返回false。它不像static_cast一样向下转换不安全，它是安全的。它的安全性体现在RTTI，那什么是RTTI呢？
RTTI是运行时类型识别。程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型（判断指针原型）。dynamic_cast和static_cast在类继承的区别就是dynamic_cast向下转换是安全的。
- reinterpreter_cast：用于不同类型之间的指针之间的转换，最常用的就是不同类型之间函数指针的转换。reinterpret_cast是一种比较粗暴的转换方式，并且是最不安全的，为什么说它粗暴呢？因为它直接去拷贝最底层的二进制，它的本质是编译器的指令，它的作用是可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。或者不同类型的指针相互转换。