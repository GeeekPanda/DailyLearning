## C++三大特性
- **封装**：于C++而言，封装实际上指的就是class，通过class把数据和函数封装在一起，对外只提供类的接口，而把实现细节隐藏起来，同时还可以通过访问权限制定数据和函数的安全等级，从而提高了安全性和隐私性。
- **继承**：继承可以理解为代码复用，是为了提高代码的复用性和可扩展性。子类继承父类，在保留“家族传统”的同时，还允许子类有自己的“小个性”。对于父类中的数据成员，子类完整的继承下来，所谓“完整”是指这种继承是要占用内存的；而对于父类的成员函数，子类继承的只是函数的**调用权**。
- **多态**：多态可以理解为接口复用，也就是通过不同的方式调用“相同的接口”将产生不同的操作。多态分为静态多态和动态多态，静态多态通过**重载**实现，动态多态通过**虚函数**实现。

## 虚函数

## static关键字
- 面向过程static
    - 修饰局部变量：静态局部变量，分配在静态存储区，若已初始化则在.data，未初始化就在.bss。
    - 修饰全局变量：静态全局变量，分配在静态存储区，若已初始化则在.data，未初始化就在.bss。
    - 修饰函数：静态函数，与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
- 面向对象static
    - 修饰类的数据成员：对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。静态数据成员分配在内存的.data/.bss。sizeof(类对象)将不包括静态数据成员所占空间。
    - 修饰类的成员函数：与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。静态成员函数在.text段。

## 智能指针

## TCP三次握手四次挥手
三次握手指的是TCP双方建立连接的过程：
客户端初始状态是CLOSED，服务端执行起来后就由CLOSED转向LISTEN状态。
- 第一次握手：客户端调用connect函数后TCP三次握手建立连接过程被激起，客户端发送第一次握手请求的SYN报文段，然后由CLOSED转换为SYN_SENT；
- 第二次握手：服务端接收到客户端发来的SYN报文段，发起第二次握手请求，向客户端发送SYNACK报文段，然后由LISTEN转换为SYN_RCVD；
- 第三次握手：客户端接收到服务端发来的SYNACK报文段，发起第三路握手请求，向服务端发送ACK报文段，然后由SYN_SENT转换为ESTABLISHED；服务端收到客户端发来的ACK报文段，也由SYN_RCVD转换为ESTABLISHED，至此双方连接建立完成。

四次挥手指的是TCP双方断开连接的过程：
双方初始状态均为ESTABLISHED。
- 第一次挥手：客户端调用close函数关闭套接字描述符，激起TCP四次挥手断开连接的过程，客户端发送第一次挥手的FIN报文段，然后由ESTABLISHED转换为FIN_WAIT_1；
- 第二次挥手：服务端收到客户端发来的FIN报文段，发起第二次挥手，向客户端发送ACK报文段，然后由ESTABLISHED转换为CLOSE_WAIT；客户端收到服务端发来的ACK报文段，由FIN_WAIT_1转换为FIN_WAIT_2；
- 第三次挥手：服务端调用close函数，发起第三次挥手，向客户端发送FIN报文段，由CLOSE_WAIT转换为LAST_ACK；
- 第四次挥手：客户端收到服务端发来的FIN报文段，发起第四次挥手，向服务端发送ACK报文段，由FIN_WAIT_2转换为TIME_WAIT；服务端收到客户端发来的ACK报文段，由LAST_ACK转换为CLOSED，至此服务端关闭；客户端等待2MSL，计时器超时后，客户端由TIME_WAIT转换为CLOSED，至此双方连接彻底关闭。

## TIME_WAIT状态
TIME_WAIT是TCP连接中主动发起关闭的一方在彻底关闭前要经历的一个状态。TIME_WAIT的时间是2MSL。
TIME_WAIT的原因有两个:
- 确保客户端能响应服务端重传的FIN的报文段；服务器第一次发送FIN报文段，客户端收到后响应ACK报文段，但是这个ACK有可能丢失，服务端迟迟收不到，就会重传FIN报文段，如果没有TIME_WAIT状态，即客户端在第一次发送ACK后就彻底关闭连接，那服务端重传的FIN报文段发送到客户端之后，客户端会响应一个重置报文段而不是ACK，那么服务端就没办法可靠的进入CLOSED状态。而有了TIME_WAIT状态，在这期间，客户端依然维持着连接状态，对于重传来的FIN，客户端可以响应ACK，从而可靠的关闭TCP连接。
- 允许老的分组在网络中消逝。一对TCP连接是由四元组（srcIP,srcPort,destIP,destPort）所确定。在TCP连接的传输过程中，可能会有一些分组在网络中迷失，如果没有TIME_WAIT状态，即直接关闭连接。那如果再以相同的四元组重建连接，这些旧连接中迷路的分组可能被新的客户端/服务端误认为是新连接的分组而接收并交付，从而产生混乱。有了TIME_WAIT状态，可以确保本次连接中的分组全部在网络中消逝，不会影响新连接。在TIME_WAIT期间，该四元组被定义为不可使用状态，无法以同样的四元组建立新连接。

> 为什么是2MSL？
> MSL是Maximun Segment Lifetime,即最大报文段生存时间。它代表了任何报文段在被丢弃前在网络中被允许存在的最长时间。RFC中规定MSL为2分钟，但常见的实现中MSL为30秒、1分钟、2分钟。这一数值是可以修改的。
## TCP UDP
- TCP全称传输控制协议，是面向连接的可靠的流式传输协议。所以常用于对网络通讯质量有较高要求的时候，比如：要求通信数据完整性，则应该选用TCP协议，如文件传输等，具体到应用层协议，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议；
- UDP是一种无连接且不保证可靠性的协议。对当前网络通讯质量要求不高，而要求网络通讯速度尽量的快，这时就使用UDP，比如视频通话、语音通话。
## socket编程
- 创建套接字socket()函数
    ```c
    #include <sys/socket.h>
    int socket(int family, int type, int protocol);
    ```
    - 参数：
        - family：设置协议域为AF_INET，即IPv4；
        - type：设置套接字类型为SOCK_STREAM，即字节流套接字；
        - protocol：设置该参数为0，表示选择根据family和type组合系统提供的默认传输层协议。对于AF_INET和SOCK_STREAM组合，默认协议为TCP。
    - 返回值：
        - 成功：返回套接字描述符；
        - 失败：返回-1。
- 客户端发起连接connect()函数
    ```c
    #include <sys/socket.h>
    int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
    ```
    - 参数：
        - sockfd:客户端socket函数返回的套接字描述符；
        - servaddr:指向一个指明了服务端IP地址和端口号的套接字地址结构；
        - addrlen:servaddr参数指向的地址结构的大小，可由sizeof()运算得到。
    - 返回值：
        - 成功：返回0；
        - 失败：返回-1。
- 服务端命名套接字bind()函数
    ```c
    #include <sys/socket.h>
    int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);
    ```
    - 参数：
        - sockfd:服务端socket函数返回的套接字描述符；
        - myaddr:指向一个指明了服务端IP地址和端口号的套接字地址结构；
        - addrlen:servaddr参数指向的地址结构的大小，可由sizeof()运算得到。
    - 返回值：
        - 成功：返回0；
        - 失败：返回-1。
- 服务端将主动套接字转化为被动套接字listen()函数
    ```c
    #include <sys/socket.h>
    int listen(int sockfd, int backlog);
    ```
    - 参数：
        - sockfd:服务端socket函数返回的套接字描述符；
        - backlog:规定了内核应该为sockfd套接字排队的最大连接个数；
    - 返回值：
        - 成功：返回0；
        - 失败：返回-1。
- 服务端接受连接请求accept()函数
    ```c
    #include <sys/socket.h>
    int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);
    ```
    - 参数：
        - sockfd:服务端socket函数返回的套接字描述符；
        - cliaddr:用于返回客户的套接字地址结构，可以NULL；
        - addrlen：用于返回cliaddr大小，可以NULL。
    - 返回值：
        - 成功：返回已连接套接字描述符；
        - 失败：返回-1。