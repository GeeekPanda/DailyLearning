## C++三大特性
- **封装**：于C++而言，封装实际上指的就是class，通过class把数据和函数封装在一起，对外只提供类的接口，而把实现细节隐藏起来，同时还可以通过访问权限制定数据和函数的安全等级，从而提高了安全性和隐私性。
- **继承**：继承可以理解为代码复用，是为了提高代码的复用性和可扩展性。子类继承父类，在保留“家族传统”的同时，还允许子类有自己的“小个性”。对于父类中的数据成员，子类完整的继承下来，所谓“完整”是指这种继承是要占用内存的；而对于父类的成员函数，子类继承的只是函数的**调用权**。
- **多态**：多态可以理解为接口复用，也就是通过不同的方式调用“相同的接口”将产生不同的操作。多态分为静态多态和动态多态，静态多态通过**重载**实现，动态多态通过**虚函数**实现。

## 虚函数

## C++内存布局
以32位的Linux系统为例，内存空间共有4GB。这4GB内存会分为两部分：
- 高地址（0xc0000000~0xffffffff）的1GB是**内核空间**，里边存放着进程相关的数据结构、协议栈等等。
- 低地址（0~0xc0000000）的3GB是**用户空间**：
    - stack：用户栈，用于维护函数调用的上下文，用户定义的局部变量也在此分配内存。大小一般为8M。
    - dynamic libraries：这里是动态链接库。
    - heap：程序用malloc或new分配内存时，就是从这里分配。
    - .data/.bss:可读可写区。已初始化的全局变量和局部静态变量在.data，未初始化的全局变量和局部静态变量在.bss。
    - .init/.rodata/.text：这里是只读区，初始化代码(.init)、const修饰的只读变量及字符串常量(.rodata)以及编译之后的二进制代码(.text)。
    - reserved:保留区，大约128M。这一段内存是受到保护而禁止访问的。比如把指针置NULL，其实就是指向地址0x0了。

## static关键字
- 面向过程static
    - 修饰局部变量：静态局部变量，分配在静态存储区，若已初始化则在.data，未初始化就在.bss。
    - 修饰全局变量：静态全局变量，分配在静态存储区，若已初始化则在.data，未初始化就在.bss。
    - 修饰函数：静态函数，与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。
- 面向对象static
    - 修饰类的数据成员：对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新。静态数据成员分配在内存的.data/.bss。sizeof(类对象)将不包括静态数据成员所占空间。
    - 修饰类的成员函数：与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部实现，属于类定义的一部分。普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this是缺省的。如函数fn()实际上是this->fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。静态成员函数在.text段。

## 智能指针
智能指针用于内存管理，主要是用于对堆上面开辟的内存的管理，具体采用引用计数的机制进行。

比如我们在堆上开辟了一块内存m1，并将其赋值给指针p1，那么现在m1这块内存就有一个对象在使用。这时如果有另外一个指针p2也需要使用m1的内容，那么就将p2也指向m1。问题在于，如果p1使用完毕之后，使用delete语句告诉系统，这块内存我不用了，把它回收吧，那么这时p2还在指着m1的话，再次使用p2的时候就会出问题了。

然后就引入了引用计数的概念。所有的堆上的内存，在还没有被开辟的时候，该块内存的引用计数为0，在第一次用p1开辟的时候引用计数+1变成1，如果有其他指针也需要这块内存，比如一个浅拷贝操作，比如p2，那么这时候就有两个指针指向m1，引用计数变成2，当p1用完了，就用一个操作切断p1和m1的关系，m1的引用计数变成1。当p2也用完了，那么通过一个操作引用计数再次减去1，引用计数变成0。当智能指针这个对象发现它管理的内存引用计数变成0的时候，对m1做一个delete操作，使之释放。

- shared_ptr:允许多个指针指向同一个对象；
- unique_ptr:独占所指对象；
- weak_ptr:是一种弱引用，指向shared_ptr管理的对象。

## TCP三次握手四次挥手
三次握手指的是TCP双方建立连接的过程：
客户端初始状态是CLOSED，服务端执行起来后就由CLOSED转向LISTEN状态。
- 第一次握手：客户端调用connect函数后TCP三次握手建立连接过程被激起，客户端发送第一次握手请求的SYN报文段，然后由CLOSED转换为SYN_SENT；
- 第二次握手：服务端接收到客户端发来的SYN报文段，发起第二次握手请求，向客户端发送SYNACK报文段，然后由LISTEN转换为SYN_RCVD；
- 第三次握手：客户端接收到服务端发来的SYNACK报文段，发起第三路握手请求，向服务端发送ACK报文段，然后由SYN_SENT转换为ESTABLISHED；服务端收到客户端发来的ACK报文段，也由SYN_RCVD转换为ESTABLISHED，至此双方连接建立完成。

四次挥手指的是TCP双方断开连接的过程：
双方初始状态均为ESTABLISHED。
- 第一次挥手：客户端调用close函数关闭套接字描述符，激起TCP四次挥手断开连接的过程，客户端发送第一次挥手的FIN报文段，然后由ESTABLISHED转换为FIN_WAIT_1；
- 第二次挥手：服务端收到客户端发来的FIN报文段，发起第二次挥手，向客户端发送ACK报文段，然后由ESTABLISHED转换为CLOSE_WAIT；客户端收到服务端发来的ACK报文段，由FIN_WAIT_1转换为FIN_WAIT_2；
- 第三次挥手：服务端调用close函数，发起第三次挥手，向客户端发送FIN报文段，由CLOSE_WAIT转换为LAST_ACK；
- 第四次挥手：客户端收到服务端发来的FIN报文段，发起第四次挥手，向服务端发送ACK报文段，由FIN_WAIT_2转换为TIME_WAIT；服务端收到客户端发来的ACK报文段，由LAST_ACK转换为CLOSED，至此服务端关闭；客户端等待2MSL，计时器超时后，客户端由TIME_WAIT转换为CLOSED，至此双方连接彻底关闭。

## TIME_WAIT状态
TIME_WAIT是TCP连接中主动发起关闭的一方在彻底关闭前要经历的一个状态。TIME_WAIT的时间是2MSL。
TIME_WAIT的原因有两个:
- 确保客户端能响应服务端重传的FIN的报文段；服务器第一次发送FIN报文段，客户端收到后响应ACK报文段，但是这个ACK有可能丢失，服务端迟迟收不到，就会重传FIN报文段，如果没有TIME_WAIT状态，即客户端在第一次发送ACK后就彻底关闭连接，那服务端重传的FIN报文段发送到客户端之后，客户端会响应一个重置报文段而不是ACK，那么服务端就没办法可靠的进入CLOSED状态。而有了TIME_WAIT状态，在这期间，客户端依然维持着连接状态，对于重传来的FIN，客户端可以响应ACK，从而可靠的关闭TCP连接。
- 允许老的分组在网络中消逝。一对TCP连接是由四元组（srcIP,srcPort,destIP,destPort）所确定。在TCP连接的传输过程中，可能会有一些分组在网络中迷失，如果没有TIME_WAIT状态，即直接关闭连接。那如果再以相同的四元组重建连接，这些旧连接中迷路的分组可能被新的客户端/服务端误认为是新连接的分组而接收并交付，从而产生混乱。有了TIME_WAIT状态，可以确保本次连接中的分组全部在网络中消逝，不会影响新连接。在TIME_WAIT期间，该四元组被定义为不可使用状态，无法以同样的四元组建立新连接。

> 为什么是2MSL？
> MSL是Maximun Segment Lifetime,即最大报文段生存时间。它代表了任何报文段在被丢弃前在网络中被允许存在的最长时间。RFC中规定MSL为2分钟，但常见的实现中MSL为30秒、1分钟、2分钟。这一数值是可以修改的。

## TCP UDP
- TCP全称传输控制协议，是面向连接的可靠的流式传输协议。所以常用于对网络通讯质量有较高要求的时候，比如：要求通信数据完整性，则应该选用TCP协议，如文件传输等，具体到应用层协议，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议；
- UDP是一种无连接且不保证可靠性的协议。对当前网络通讯质量要求不高，而要求网络通讯速度尽量的快，这时就使用UDP，比如视频通话、语音通话。

## socket编程
- 创建套接字socket()函数
    ```c
    #include <sys/socket.h>
    int socket(int family, int type, int protocol);
    ```
    - 参数：
        - family：设置协议域为AF_INET，即IPv4；
        - type：设置套接字类型为SOCK_STREAM，即字节流套接字；
        - protocol：设置该参数为0，表示选择根据family和type组合系统提供的默认传输层协议。对于AF_INET和SOCK_STREAM组合，默认协议为TCP。
    - 返回值：
        - 成功：返回套接字描述符；
        - 失败：返回-1。
- 客户端发起连接connect()函数
    ```c
    #include <sys/socket.h>
    int connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);
    ```
    - 参数：
        - sockfd:客户端socket函数返回的套接字描述符；
        - servaddr:指向一个指明了服务端IP地址和端口号的套接字地址结构；
        - addrlen:servaddr参数指向的地址结构的大小，可由sizeof()运算得到。
    - 返回值：
        - 成功：返回0；
        - 失败：返回-1。
- 服务端命名套接字bind()函数
    ```c
    #include <sys/socket.h>
    int bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen);
    ```
    - 参数：
        - sockfd:服务端socket函数返回的套接字描述符；
        - myaddr:指向一个指明了服务端IP地址和端口号的套接字地址结构；
        - addrlen:servaddr参数指向的地址结构的大小，可由sizeof()运算得到。
    - 返回值：
        - 成功：返回0；
        - 失败：返回-1。
- 服务端将主动套接字转化为被动套接字listen()函数
    ```c
    #include <sys/socket.h>
    int listen(int sockfd, int backlog);
    ```
    - 参数：
        - sockfd:服务端socket函数返回的套接字描述符；
        - backlog:规定了内核应该为sockfd套接字排队的最大连接个数；
    - 返回值：
        - 成功：返回0；
        - 失败：返回-1。
- 服务端接受连接请求accept()函数
    ```c
    #include <sys/socket.h>
    int accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);
    ```
    - 参数：
        - sockfd:服务端socket函数返回的套接字描述符；
        - cliaddr:用于返回客户的套接字地址结构，可以NULL；
        - addrlen：用于返回cliaddr大小，可以NULL。
    - 返回值：
        - 成功：返回已连接套接字描述符；
        - 失败：返回-1。

## Linux常用命令