# I/O模型
IO其实就是内存和磁盘、网卡等外部设备之间的数据交互，但是用户程序没有权限直接访问外部设备，只能通过内核来间接访问它们，所以IO过程实际指的是用户空间和内核空间的数据交互。站在程序员的角度，从内核空间复制数据到用户空间的过程叫做“读(Input)”，反之叫做“写(Output)”。一次读（写）由两个阶段组成：
1. 检查内核空间是否有数据可读（有空间可写）；
2. 复制数据到用户空间（内核空间）。

这两个阶段决定着各种IO模型的类型，Unix有以下5种IO模型：
- 阻塞IO
- 非阻塞IO
- IO多路复用
- 信号驱动IO
- 异步IO

## 阻塞IO
什么是阻塞。从进程或线程的角度来看，阻塞就是因为当前执行的这个进程或线程，因等待某个暂时没有准备好的数据而失去了CPU的使用权，进入阻塞态。

如果是具体的IO的话，则可以理解为，阻塞的时候该进程/线程需要等待，等到数据准备好，才能继续下一步的操作，不然只能一直等待下去。而非阻塞，则是，即便数据没有准备好，它也可以去做其他的事情。

对应到上面的两个阶段，如果等待内核准备数据的时候，执行线程可以去做其他的事，那么在第一阶段就是非阻塞的，否则就是阻塞的。

如果在数据从内核空间拷贝到用户空间阶段，执行线程可以去干其他的事，那么第二阶段就是非阻塞的，否则就是阻塞的。

而阻塞IO就是一种两个阶段都是阻塞的IO模型。用户程序发起IO请求，发现内核没把数据准备好，它就在那傻等，知道内核把数据准备好，把数据从内核空间拷贝到用户空间后，再返回。在这之间，它啥也干不了，只能等。


## 非阻塞IO
非阻塞IO是第一个阶段不阻塞，第二阶段阻塞的IO。

当用户程序发起IO请求，内核没把数据准备好，内核会立刻给用户程序返回一个错误，然后用户程序就会一直轮询，以查看内核是否把数据准备好，当某一次轮询中内核已经把数据准备好了，就会执行第二阶段的数据拷贝。

这样的轮询耗费了大量CPU资源。


## IO多路复用
IO多路复用是用户程序通过select/poll/epoll函数告诉内核我们对哪些文件描述的哪些事件（读、写、异常等）感兴趣，以及我们愿意等待多长时间。当感兴趣的事件（比如可读、可写等）准备好时，select/poll/epoll_wait函数会返回，用户程序就可以开始第二阶段的数据拷贝。

所以IO多路复用是两个阶段都阻塞的IO模型，只是第一阶段的阻塞不是阻塞在真正的IO系统调用上，而是阻塞在select/poll/epoll_wait函数上。



## 信号驱动IO
信号驱动IO是第一个阶段不阻塞，第二个阶段阻塞的IO模型。

信号驱动IO是用户程序通过sigaction系统调用安装一个信号处理函数，

## 异步IO

前四种都是同步IO。
同步IO与异步IO的区别在于获知内核空间有数据可读（有空间可写）后，复制数据到用户空间（内核空间）的操作具体由谁来执行。